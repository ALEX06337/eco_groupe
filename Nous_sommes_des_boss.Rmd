---
title: "Cours Shiny"
author: "Moi"
date: "2024-09-09"
output: html_document
---

```{r arima}
# Load necessary libraries
library(shiny)
library(quantmod)
library(forecast)
library(ggplot2)
library(DT)

file <- "NYSE.csv"
df1 <- read.csv2(file, header = TRUE, sep = ";")

# Define the user interface
ui <- fluidPage(
  titlePanel("Prédiction du cours des actions avec le modèle ARIMA"),
  actionButton('help','Instruction Book'),
  actionButton('yahoo','Yahoo', onclick = "window.open('https://fr.finance.yahoo.com/', '_blank')"),
  sidebarLayout(
    sidebarPanel(
      # The textInput for symbol is commented out; we will use the selectizeInput instead
      # textInput("symbol", "Entrez le symbole de l'action :", value = "AAPL"),
      selectizeInput(
        inputId = "entreprise",
        label = "Tapez et sélectionnez :",
        choices = unique(df1$Description),
        options = list(
          placeholder = "Commencez à taper...",
          create = FALSE
        )
      ),
      dateRangeInput("dates", "Sélectionnez la période :",
                     start = Sys.Date() - 365 * 5,
                     end = Sys.Date()),
      numericInput("forecast_horizon", "Horizon de prévision (jours) :", value = 30, min = 1, max = 365),
      actionButton("goButton", "Lancer la prévision")
    ),
    mainPanel(
      tabsetPanel(
        tabPanel("Données historiques", plotOutput("time_series_plot")),
        tabPanel("Prévision ARIMA", plotOutput("arima_forecast_plot")),
        tabPanel("Métriques du modèle", verbatimTextOutput("model_metrics"))
      )
    )
  )
)

# Define the server logic
server <- function(input, output) {
  # Create a reactive expression to get the symbol based on the selected company
  symbol <- reactive({
    req(input$entreprise)
    selected_row <- df1[df1$Description == input$entreprise, ]
    if (nrow(selected_row) == 0) {
      showNotification("Symbole introuvable pour l'entreprise sélectionnée.", type = "error")
      return(NULL)
    } else {
      return(selected_row$Symbol)
    }
  })

  # Reactive function to fetch stock data
  stock_data <- eventReactive(input$goButton, {
    req(symbol())
    req(input$dates)
    tryCatch({
      getSymbols(Symbols = symbol(), src = "yahoo",
                 from = input$dates[1],
                 to = input$dates[2],
                 auto.assign = FALSE)
    }, error = function(e) {
      showNotification(paste("Erreur lors de la récupération des données :", e$message), type = "error")
      return(NULL)
    })
  })

  # Plot of historical data
  output$time_series_plot <- renderPlot({
    data <- stock_data()
    req(data)
    adjusted <- Ad(data)
    plot(adjusted, main = paste("Cours de clôture ajusté de", symbol()),
         ylab = "Prix", xlab = "Date")
  })

  # ARIMA modeling and forecasting
  arima_result <- reactive({
    data <- stock_data()
    req(data)
    adjusted <- Ad(data)
    dates <- index(adjusted)
    adjusted_df <- data.frame(Date = dates, Adjusted = as.numeric(adjusted))
    n <- nrow(adjusted_df)
    if (n < 10) {
      showNotification("Pas assez de données pour construire le modèle.", type = "error")
      return(NULL)
    }
    train_size <- floor(n * 0.8)
    train_df <- adjusted_df[1:train_size, ]
    test_df <- adjusted_df[(train_size + 1):n, ]
    train_ts <- ts(train_df$Adjusted, frequency = 252)
    model <- auto.arima(train_ts)
    h <- min(input$forecast_horizon, nrow(test_df))
    forecast_values <- forecast(model, h = h)
    rmse <- if (h > 0) {
      sqrt(mean((forecast_values$mean - test_df$Adjusted[1:h])^2, na.rm = TRUE))
    } else {
      NA
    }
    # Prepare data for plotting
    forecast_df <- data.frame(Date = test_df$Date[1:h],
                              Forecast = as.numeric(forecast_values$mean),
                              Lower = forecast_values$lower[,2],
                              Upper = forecast_values$upper[,2])
    list(forecast_df = forecast_df, test_df = test_df[1:h, ], rmse = rmse, model = model)
  })

  # Plot of ARIMA forecast
  output$arima_forecast_plot <- renderPlot({
    res <- arima_result()
    req(res)
    forecast_df <- res$forecast_df
    test_df <- res$test_df

    ggplot() +
      geom_line(data = test_df, aes(x = Date, y = Adjusted), color = "blue", size = 1, linetype = "dashed") +
      geom_line(data = forecast_df, aes(x = Date, y = Forecast), color = "red", size = 1) +
      geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower, ymax = Upper), fill = "grey70", alpha = 0.5) +
      ggtitle(paste("Prévision ARIMA pour", symbol())) +
      xlab("Date") + ylab("Prix") +
      theme_minimal()
  })

  # Display model metrics
  output$model_metrics <- renderPrint({
    res <- arima_result()
    req(res)
    cat("Résumé du modèle ARIMA pour", symbol(), ":\n")
    print(summary(res$model))
    if (!is.na(res$rmse)) {
      cat("\nRMSE :", round(res$rmse, 4))
    } else {
      cat("\nRMSE non disponible (pas de données de test).")
    }
  })
}

# Run the application
shinyApp(ui = ui, server = server)



```

### Modélisation ARIMA et prévision

```r
arima_result <- reactive({
  data <- stock_data()
  req(data)
  adjusted <- Ad(data)
  dates <- index(adjusted)
  adjusted_df <- data.frame(Date = dates, Adjusted = as.numeric(adjusted))
  n <- nrow(adjusted_df)
  if (n < 10) {
    showNotification("Pas assez de données pour construire le modèle.", type = "error")
    return(NULL)
  }
  train_size <- floor(n * 0.8)
  train_df <- adjusted_df[1:train_size, ]
  test_df <- adjusted_df[(train_size + 1):n, ]
  train_ts <- ts(train_df$Adjusted, frequency = 252)
  model <- auto.arima(train_ts)
  h <- min(input$forecast_horizon, nrow(test_df))
  forecast_values <- forecast(model, h = h)
  rmse <- if (h > 0) {
    sqrt(mean((forecast_values$mean - test_df$Adjusted[1:h])^2, na.rm = TRUE))
  } else {
    NA
  }
  # Préparer les données pour le graphique
  forecast_df <- data.frame(Date = test_df$Date[1:h],
                            Forecast = as.numeric(forecast_values$mean),
                            Lower = forecast_values$lower[,2],
                            Upper = forecast_values$upper[,2])
  list(forecast_df = forecast_df, test_df = test_df[1:h, ], rmse = rmse, model = model)
})
```

#### Explication détaillée :

1. **Préparation des données :**

   - **Récupération des données :** On récupère les données boursières via `stock_data()`.

   - **Extraction des prix ajustés :** `adjusted <- Ad(data)` extrait les prix de clôture ajustés.

   - **Création d'un dataframe :** `adjusted_df` contient les dates et les prix ajustés.

2. **Vérification du nombre de données :**

   - On s'assure qu'il y a au moins 10 observations pour construire un modèle fiable. Sinon, une notification est affichée.

3. **Division en ensembles d'entraînement et de test :**

   - **Ensemble d'entraînement (80%) :** `train_df`

   - **Ensemble de test (20%) :** `test_df`

4. **Conversion en série temporelle :**

   - Les données d'entraînement sont converties en série temporelle avec une fréquence de 252 (approximativement le nombre de jours de trading par an).

5. **Construction du modèle ARIMA :**

   - **`auto.arima(train_ts)`** : Cette fonction sélectionne automatiquement les meilleurs paramètres \( p, d, q \) du modèle ARIMA en fonction des données.

6. **Prévision :**

   - **Horizon de prévision :** `h` est le nombre de périodes à prévoir, limité par la taille de l'ensemble de test.

   - **Prévisions :** `forecast_values` contient les valeurs prédites et les intervalles de confiance.

7. **Calcul du RMSE :**

   - **RMSE (Root Mean Square Error)** : Mesure l'écart quadratique moyen entre les valeurs prédites et les valeurs réelles.

   - **Formule :**

     \[
     \text{RMSE} = \sqrt{\frac{1}{h} \sum_{i=1}^{h} (\text{Prévu}_i - \text{Réel}_i)^2}
     \]

8. **Préparation des données pour le graphique :**

   - **`forecast_df`** : Contient les dates, les prévisions et les intervalles de confiance.

   - La fonction retourne une liste contenant les données nécessaires pour les étapes suivantes.

---


---

## Explication du modèle ARIMA

### Introduction

Le modèle ARIMA (**AutoRegressive Integrated Moving Average**) est un modèle statistique utilisé pour analyser et prévoir les séries temporelles univariées. Il est particulièrement utile pour les données qui présentent des autocorrélations, c'est-à-dire lorsque les valeurs passées influencent les valeurs futures.

### Composantes du modèle ARIMA

Un modèle ARIMA est défini par trois paramètres : **p**, **d**, **q**.

- **AR(p)** : Partie auto-régressive du modèle. Elle exprime la variable en fonction de ses valeurs passées.

- **I(d)** : Différenciation pour rendre la série stationnaire. Une série est stationnaire si ses propriétés statistiques (moyenne, variance) sont constantes dans le temps.

- **MA(q)** : Partie moyenne mobile du modèle. Elle exprime la variable en fonction des erreurs de prévision passées.

### Formulation mathématique

#### Partie Auto-régressive (AR(p))

La partie auto-régressive d'ordre \( p \) est donnée par :

\[
y_t = c + \phi_1 y_{t-1} + \phi_2 y_{t-2} + \dots + \phi_p y_{t-p} + \varepsilon_t
\]

- \( y_t \) : Valeur de la série à l'instant \( t \).

- \( c \) : Constante.

- \( \phi_i \) : Coefficients auto-régressifs à estimer.

- \( \varepsilon_t \) : Erreur aléatoire à l'instant \( t \).

#### Différenciation (I(d))

Pour rendre la série stationnaire, on applique une différenciation d'ordre \( d \) :

- Différenciation d'ordre 1 :

  \[
  y'_t = y_t - y_{t-1}
  \]

- Après différenciation, on modélise \( y'_t \) plutôt que \( y_t \).

#### Partie Moyenne Mobile (MA(q))

La partie moyenne mobile d'ordre \( q \) est donnée par :

\[
y_t = c + \varepsilon_t + \theta_1 \varepsilon_{t-1} + \theta_2 \varepsilon_{t-2} + \dots + \theta_q \varepsilon_{t-q}
\]

- \( \theta_i \) : Coefficients de moyenne mobile à estimer.

### Combinaison ARIMA(p, d, q)

Le modèle ARIMA combine ces trois composantes :

\[
\Delta^d y_t = c + \phi_1 \Delta^d y_{t-1} + \dots + \phi_p \Delta^d y_{t-p} + \varepsilon_t + \theta_1 \varepsilon_{t-1} + \dots + \theta_q \varepsilon_{t-q}
\]

- \( \Delta^d y_t \) : Série différenciée d'ordre \( d \).

### Estimation du modèle

- **Sélection des ordres \( p, d, q \) :**

  - **`auto.arima()`** automatise ce processus en testant différentes combinaisons et en sélectionnant celle qui minimise un critère d'information (AIC, BIC).

- **Ajustement des paramètres :**

  - Les coefficients \( \phi_i \) et \( \theta_i \) sont estimés à l'aide de méthodes statistiques (par exemple, maximum de vraisemblance).

### Prévision

- Une fois le modèle ajusté, on peut prévoir les valeurs futures de la série.

- Les prévisions sont calculées en utilisant les coefficients estimés et les valeurs passées de la série.

### Intervalles de confiance

- Les intervalles de confiance fournissent une estimation de l'incertitude associée aux prévisions.

- Ils sont calculés en fonction de la variance des erreurs et de la structure du modèle.

### Évaluation du modèle

- **RMSE (Root Mean Square Error) :**

  - Mesure la précision des prévisions en calculant la moyenne des carrés des erreurs entre les valeurs prédites et les valeurs réelles.

- **Autres métriques :**

  - AIC (Akaike Information Criterion), BIC (Bayesian Information Criterion) pour la sélection du modèle.

---

## Application du modèle ARIMA aux données boursières

### Particularités des données financières

- **Non-stationnarité :** Les prix des actions sont souvent non stationnaires en moyenne et en variance.

- **Volatilité :** La variance des rendements peut changer au fil du temps.

### Prétraitement des données

- **Stationnarisation :**

  - La différenciation (I(d)) est utilisée pour éliminer les tendances et rendre la série stationnaire.

- **Transformation logarithmique :**

  - Parfois utilisée pour stabiliser la variance.

### Limitations

- **Modèle linéaire :** L'ARIMA est un modèle linéaire et peut ne pas capturer des relations non linéaires complexes.

- **Hypothèse de normalité :** Les erreurs sont supposées normalement distribuées, ce qui peut ne pas être le cas dans les données financières.

- **Prédictions à long terme :** Les prévisions deviennent moins fiables à mesure que l'horizon de prévision s'allonge.

---

## Conclusion

Votre code implémente une application complète pour l'analyse et la prévision des cours boursiers en utilisant le modèle ARIMA. En comprenant les bases mathématiques de l'ARIMA, vous pouvez mieux interpréter les résultats et ajuster le modèle en fonction de vos besoins.

**Points clés :**

- **Préparation des données :** Vérifiez toujours la stationnarité de votre série temporelle et appliquez les transformations nécessaires.

- **Sélection du modèle :** Le choix des paramètres \( p, d, q \) est crucial. L'utilisation de `auto.arima()` facilite ce processus.

- **Évaluation du modèle :** Utilisez des métriques comme le RMSE pour évaluer la performance du modèle.

- **Interprétation des résultats :** Gardez à l'esprit les limitations du modèle lors de l'interprétation des prévisions.

---

**N'hésitez pas à me poser des questions supplémentaires si vous souhaitez approfondir certains aspects ou si vous avez besoin d'éclaircissements sur des parties spécifiques du code ou du modèle ARIMA.**













```{r}
library(shiny)
library(shinyWidgets)
library(quantmod)
library(ggplot2)
library(dplyr)


file <- "NYSE.csv"
df1 <- read.csv2(file, header = TRUE, sep = ";")
# Ajoute un symbol et sa description (à la main, j'ai pas confiance aux utilisateurs) ok Vlad ? ;)
# (df1 <- rbind(df1, c("symbol", "la description")))
# write.csv2(df1, file = file, row.names = FALSE)

day <- c(1, 7, 30, 90, 365)
names(day) <- c('Jour', 'Semaine', 'Mois', 'Trimestre', 'An')


ui <- fluidPage(
  titlePanel("Analyse et prédiction du cours des actions"),
  hr(),
  actionButton('help','Instruction Book'),
  actionButton('yahoo','Yahoo', onclick = "window.open('https://fr.finance.yahoo.com/', '_blank')"),
  br(),
  br(),
  sidebarLayout(
    sidebarPanel(
      selectizeInput(
        inputId = "entreprise",
        label = "Tapez et sélectionnez :",
        choices = unique(df1$Description),
        options = list(
            placeholder = "Commencez à taper...",
            create = FALSE
        )
      ),
      uiOutput('dynamic_var'),
      
      selectInput('period', "Choice your periode", choices = c('Jour', 'Semaine', 'Mois', 'Trimestre', 'An')),
      
      uiOutput('dynamic_period')
        
    ),
    mainPanel(
      tabsetPanel(
        tabPanel(
          "Global",
          tabsetPanel(
            tabPanel(
              'Plot',
               br(),
              plotOutput("plot")
            ),
            tabPanel(
              'Table',
               br(),
               DT::DTOutput("table")
            )
          )
        ),
        tabPanel(
          "Prévision",
          tabsetPanel(
            tabPanel(
              "Exponentiel",
              br(),
              plotOutput("expo")
            )
          )
        )
      )
    )
  )
)


server <- function(input, output) {
  observeEvent(input$help, {
    showModal(modalDialog(
        title = "Mode Action",
        "Entrer le symbole du nom de l'action choisi (le nom entre parenthèse) et le nombre de trimestre pour la prévision")
      )
  })
  
  symbol <- reactive({
    df1[df1$Description == input$entreprise, "Symbol"]
  })
  
  recup <- reactive({
    df <- tryCatch(
      {
        # Code pouvant provoquer une erreur
        getSymbols(symbol(), src = "yahoo", auto.assign = FALSE)
      },
      error = function(e) {
        # Action en cas d'erreur (pas d'erreur ici mais personne connaît l'avenir)
        df1 <- df1[df1$Symbol != symbol(), ] # Supprime le symbole
        write.csv2(df1, file = file, row.names = FALSE) # Mise à jour du fichier
        
        print("Une erreur est survenue :")
        print(e$message)
        return(NULL) # Retourner une valeur par défaut
      },
      warning = function(w) {
        # Action en cas d'avertissement
        df1 <- df1[df1$Symbol != symbol(), ]
        write.csv2(df1, file = file, row.names = FALSE)
        
        print("Un avertissement est survenu :")
        print(w$message)
        return(NULL)
      },
      finally = {
        # Action à effectuer quoi qu'il arrive
        print("Fin de l'exécution.")
      }
    )
    if (is.null(df) == FALSE) {
      df <- data.frame(Date = index(df), coredata(df))
    }
    
    return(df)
  })
  
  output$dynamic_var <- renderUI({
    validate(
      need(input$entreprise != "", "\n")
    )
    if (is.null(recup()) == FALSE) {
      df <- recup()
      selectInput('var', 'Choice Y', choices = unique(colnames(df[-1])))
    }
  })
  
  # Global
  output$plot <- renderPlot({
    validate(
      need(input$entreprise != "", "Please, enter your entreprise !"),
    )
    if (is.null(recup()) == FALSE) {
      ggplot(recup(), aes(x = Date, y = .data[[input$var]])) + geom_line() + labs(title = paste("Prévision de", input$var, "pour", input$entreprise))
    } else {
      showModal(modalDialog(
        title = "Error",
        "Yahoo ne reconnaît plus cette entreprise, veuillez en entrer une autre !")
      )
    }
  })

  output$table <- DT::renderDataTable({
    validate(
      need(is.null(recup()) == FALSE, "Please, enter an other entreprise !")
    )
    recup()
  })
  
  
  # Prévision
   output$dynamic_period <- renderUI({
    numericInput('date', paste('Sur combien de', input$period, 'la prédiction'), value = 2, min = 1)
  })
   
  ## Exponentielle
  expo <- function(df){
    nui <- input$date * day[input$period]
    n <- ifelse(nui*16<4500, nui*16, 4500)
    nfinal <- n + nui
    y <- tail(df[[input$var]], n = n)
    x <- 1:n
    b <- exp(coef(lm(log(y) ~ x))["x"]) # Pente
    a <- exp(coef(lm(log(y) ~ x))["(Intercept)"]) # Origine
    
    Ct <- a*b^x
    Ctfinal <- a*b^(1:(nfinal))
    
    tableau <- array(y/Ct, dim = c(2, 2, n/4))
    
    
    Siprime <- function(tableau, sum = 0, Si = 0) {
      nmat <- length(tableau)/4
      for (row in 1:2) {
        for (col in 1:2) {
          for (mat in 1:nmat) {
            sum <- sum + tableau[row,col,mat]
          }
          Si <- c(Si, sum/nmat)
          sum <- 0
        }
      }
      Si <- Si[-1]
      Siprime <- Si/mean(Si)
      return(Siprime)
    }
    
    if (nui%%4 == 0) {
      Stfinal <- c(rep(Siprime(tableau), times = (n/4 + (nui-(nui%%4))/4)))
    } else {
      Stfinal <- c(rep(Siprime(tableau), times = (n/4 + (nui-(nui%%4))/4)), Siprime(tableau)[1:(nui%%4)])
    }
    
    modele <- Ctfinal*Stfinal
    plot((1:nfinal), modele)
  }
  
  output$expo <- renderPlot({
    validate(
      need(is.null(recup()) == FALSE, "Please, enter an other entreprise !")
    )
    expo(recup())
  })
  

  
  
  
  
  
  
  
}

shinyApp(ui = ui, server = server)
```
